# 파이썬 알고리즘 인터뷰

## 10. 데크, 우선순위 큐
- 데크 (Deque)
  - 스택과 큐의 연산을 모두 갖고 있는 복합 자료형
  - Double-Ended Queue의 줄임말
  - 양쪽 끝을 모두 추출할 수 있는, 큐를 일반화한 형태의 추상 자료형(ADT).
  - 구현은 배열이나 연결 리스트 모두 가능하지만, 특별히 이중 연결 리스트로 구현하는 편이 가장 잘 어울림
    - ![image](https://user-images.githubusercontent.com/97150219/232277549-666418f1-2002-4163-954f-4c7fe1fa9f64.png)
    - 이중 연결리스트로 구현하게 되면, head와 tail이라는 이름의 투 포인트를 가지게 됨
    - 새로운 아이템이 추가될 때마다 앞쪽 또는 뒤쪽으로 연결시켜주기
    - 연결 후에는 포인터 이동
  - collections 모듈에서 deque라는 이름으로 지원
    - collections.deque는 이중 연결 리스트로 구현되어 있음.

### 641) Design Circular Deque
- Medium

#### 의식의 흐름
- deque를 직접 구현하려면 이중 연결리스트 클래스부터 정의?
- 어디서부터 정의해줘야할지 모르겠다..! 솔루션 앞부분 참고
  - ListNode 사용해준거면 ListNode도 따로 정의해줘야하는 것 아닌가?
  - insertFront 메소드에서 _add -> 템플릿에 없는 새로운 메소드 추가?
- inserfFront -> head에 _add 해준 후 head 바꿔줘야하는것 아닌가
- 의문점이 너무 많아서 솔루션 전체를 읽어봐야겠다!

#### Solution
```python

```
- _add
  - 이중 연결리스트에 신규 노드 삽입
  - _add에서 '_' : 내부에서만 사용한다는 의미
  - 오른쪽에 새로운 노드 삽입

- 의문점 -> 해결 후 코드 추가 예정
  - ListNode 정의
  - head, tail 변경
  - _del에서 node삭제가 아니라 node.right을 삭제하고 있는게 아닌가

- 사실상 원형 데크를 이중 연결리스트로 구현하게 되면 원형의 이점을 살릴 수 없게 됨.
  - 원형으로 구현하는 이유는 뒤쪽으로 요소를 채우다가 공간이 다 차게되면 tail과 head를 연결해 앞쪽의 빈 공간을 활용하려는 의도인데,  
    연결리스트는 애초에 빈 공간이라는 개념이 존재하기 않기 때문에 원형은 아무런 의미가 없게 됨.
  - 데크의 연산은 맨 처음과 맨 끝의 값을 추출할 뿐, 맨 끝의 다음 값을 추출하는지 등의 연산은 존재 X  
    -> 서로 연결되어 있을 필요 또한 없음
   
## 11. Hash Table
- Hash table
  - 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)

### Hash
- 해시 함수 : 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수
- ex)  
  ABC     -> A1  
  1324BC  -> CB  
  AF32B   -> D5  
  각각 글자 수는 다르지만 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑됨.  
  이때 화살표 역할을 하는 함수가 해시 함수
- 해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것이 Hashing
- 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법
- 최적의 검색이 필요한 분야에 사용됨
- 성능 좋은 해시 함수들의 특징
  - 해시 함수 값 충돌의 최소화
  - 쉽고 빠른 연산
  - 해시 테이블 전체에 해시 값이 균일하게 분포
  - 사용할 키의 모든 정보를 이용하여 해싱
  - 해시 테이블 사용 효율이 높을 것

#### Birthday Problem
- 생각보다 충돌이 쉽게 일어나는 흔한 예
- 생일의 가짓수는 365개이므로, 비둘기집 원리(Pigeonhole Principle)에 따라 366명 이상이 모여야 생일이 같은 2명이 존재할 것 같지만  
  실제로는 23명만 모여도 50%를 넘고, 57명이 모이면 99%를 넘어섬
- 실험
  ```python
  import random
  
  TRIALS = 100000
  same_birthdays = 0  # 생일이 같은 사람이 있는 실험의 수
  
  # 10만번 실험 진행
  for _ in range(TRIALS):
    birthdays = []
    
    # 23명이 모였을 때, 생일이 같은 경우 same_birthdays += 1 후 break
    for i in range(23):
      birthday = random.randint(1, 365)
      if birthday in birthdays:
        same_birthdays += 1
        break
      birthdays.append(birthday)
      
  # 전체 10만 번 실험 중 생일이 같은 사람이 있는 실험의 확률
  print(f'{same_birthdays / TRIALS * 100}%')
  ```
  -> 50.708%
  
#### Load Factor
- 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것  
  load factor = n / k
- 로드 팩터 비율에 따라 해시 함수를 재작성해야 될지 / 해시 테이블의 크기를 조정해야 할지 결정
- 해시 함수가 키들을 잘 분산해 주는지 말하는 효율성 측정에도 사용
- 자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며, '시간과 공간 비용의 적절한 절충안'이라고 얘기  
  0.75를 넘어설 경우 동적 배열처럼 해시 테이블 공간 재할당
- 일반적으로 로드 팩터가 증가할수록 해시 테이블 성능 감소

#### Hash Function
- Hashing : 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것
- 최상의 분포를 제공하는 방법은 데이터에 따라 제각각
- Modulo-Division Method (모듈로 연산을 이용한 나눗셈 방식)
  - 가장 단순하면서 널리 쓰이는 정수형 해싱 기법
  - h(x) = x mod m
  - m = 해시 테이블 크기

### Collision (충돌)
- 아무리 좋은 해시 함수라도 충돌 발생

#### Separate Chaining (개별 체이닝)
- 충돌 발생 시 연결 리스트로 연결하는 방식
- 원리  
  1. 키의 해시 값 계산  
  2. 해시 값을 이용해 배열의 인덱스 구하기  
  3. 같은 인덱스 있다면 연결리스트로 연결  
- 잘 구현한 경우 : 대부분의 탐색 O(1)  
- 최악의 경우 (모든 해시 충돌이 발생한 경우) : O(n)

#### Open Addressing
- 충돌 발생 시 탐사(Probing)를 통해 빈 공간을 찾아나서는 방식
- 무한정 저장할 수 있는 체이닝 방식과 달리, 전체 슬롯의 개수 이상 저장 X,  
  모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장 X
- Linear Probing (선형 탐사)
  - 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사 진행
  - 특정 위치가 선점되어 있으면 그 다음 위치 확인
  - 구현 방식 간단, 의외로 전체적 성능 좋은 편
  - But 데이터들이 고르게 분포되지 않고 뭉치는 경향 -> Clustering
    - 클러스터들이 점점 커지게 되면 인근 클러스터들과 합쳐지는 일 발생
    - 탐사 시간 증가, 해싱 효율 감소
- 버킷 사이즈보다 큰 경우 삽입 X
  - 일정 기준(로드 팩터 비율) 넘어서면 Growth Factor의 비율에 따라 더 큰 크기의 또 다른 버킷 생성 후 새롭게 복사 (Rehashing)

#### 각 언어별 해시 테이블 구현 방식
- C++(GCC libstdc++) : 개별 체이닝
- Java : 개별 체이닝
- Go : 개별 체이닝
- 루비 : 오픈 어드레싱
- Python : 오픈 어드레싱
  
### 706) Design HashMap
- Easy

#### 의식의 흐름


#### Solution

```python

```

#### What I learned
