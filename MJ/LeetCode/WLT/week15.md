## 628. Maximum Product of Three Numbers 

** 문제 풀이 **
- 처음에는 brute-force 방식으로 풀어서 시간초과가 떴다. 이는 가능한 모든 subarray의 경우를 조회한 것이지, 그 중에서 maximum multiple value를 찾는 과정은 하나도 없기 때문이다.
- 일반적인 dp문제와 다르게 풀었던 부분은, dp[i]가 하나의 dp[i-1]로 결정되는 것이 아니라, dp[i-1]이 여러 개라서 dp[i]도 여러 개가 될 수 있다는 점이었다. 이는 dp[i]가 i번째 숫자로 끝나는 subarray의 최대 multiple value가 아니라, i번째 숫자로 끝나는 subarray의 muliple value가 될 수 있는 수로 정의되었기 때문이다. 왜냐하면 뒤에 어떤 숫자가 나오느냐에 따라서 (음수가 있기 때문에) 곱셈의 결과를 당장 결정지을 수 있는 것이 아니기 때문이다. 따라서 O(3n)으로 해결할 수 있었다.
- 또한, dp[i]를 저장할 때, set()을 써서 시간 초과를 해결하였는데, 이는 조회해야 할 중복되는 수를 줄였기 때문이다. 중복된 값을 조회하지 않도록 처리해주지 않으면 최악의 경우 O(n^2)가 나올 수 있다. 

** 코드 리뷰 **
- 다른 사람의 풀이를 보니, minCur, maxCur을 써서 해결하였다. O(3n)이 나오는 이유도, 결국 절댓값으로 가장 큰 숫자를 선택하는 과정이라 결국 같은 과정이었다.
- 특히, 다른 사람의 풀이를 보니 메모이제이션을 사용하지 않았다. dp이지만, 이전 값을 사용할 뿐, 이전 값을 저장해두지는 않는다. 나도 for문에서 dp[i]가 리스트라면, 더이상 dp[i]은 다음 스텝에서는 쓰이지 않기 때문에 리스트에 있는 것 중 가장 max 값만 남겨두었다. 이 말은, 즉 저장해둘 필요가 없다는 것이고 메모리를 아낄 수 있는 부분이라 내 submission 코드에 반영하였다. 이를 통해 메모리를 1MB 줄여서 beats 5%에서 beats 68%로 향상시킬 수 있었다.

## 686. Repeated String Match
** 문제 풀이 **
- 이 문제의 유형을 처음에는 알 수 없었다. 이 문제를 2가지로 쪼개어 본다면 1) b가 repeated_a에 포함되는가? 2) 언제까지 a를 반복하면서 확인하는가? (종료 조건)을 찾는 단계로 이루어져 있기 때문이었다. 문제를 풀고 대략적으로 종료 조건이 나올 때까지 while문을 돌다가, 2가지 종료 조건을 만날 수 있다고 생각되었다. 1) b가 a 안에 있으면 통과, 2) len(b)*2보다 repeated_a의 길이가 길때까지도 통과되지 못하면 종료 하는 조건이다. 

- 막상 구현하고보니 greedy 알고리즘이었다. 두 종료 조건을 만족하는 순간 while문을 나오기 때문이다. 중요한 것은 종료 조건이 greedy로 문제가 만족할만큼 정당성이 있는가였다. 종료조건 2)의 정당성은 다음과 같다. 
1) repeat을 했을 때 나올 수 있는 새로운 조합은 항상 반복된다. 따라서 2번 반복해도 b에 있지만 a에는 없는 문자는 나올 수 없다. 
2) 최악의 경우 'a'의 마지막 문자가 'b'의 시작 문자가 된다면, a는 최소한 len(b)의 길이*2까지는 반복해봐야 다 보았다고 할 수 있다. 
따라서 len(b)*2를 만족하면서, repeat을 2번 한 문자열은 b in a 통과 여부를 결정짓는 최소한의 종료 조건이 될 수 있다. 

** 코드 리뷰 **
- 반복문을 재귀로 푼 사람도 있었다.
- 패턴을 활용한 사람은, a를 반복해서 얻을 수 있는 새로운 조합이 몇 번 나오는가 
ex) abc면 새로운 패턴은 ab'ca'bc에서 ca인데, ca가 1번 나오냐, 2번 나오냐는 패턴으로 반복문을 아예 사용하지 않은 코드도 있었다. b1...aaa..bn 이런 패턴을 잘 분석하였던 사례였다.